#
# git-flow -- A collection of Git extensions to provide high-level
# repository operations for Vincent Driessen's branching model.
#
# A blog post presenting this model is found at:
#    http://blog.avirtualhome.com/development-workflow-using-git/
#
# Feel free to contribute to this project at:
#    http://github.com/petervanderdoes/gitflow
#
# Authors:
# Copyright 2012 Peter van der Does. All rights reserved.
#
# Original Author:
# Copyright 2010 Vincent Driessen. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

#
# Common functionality
#

# Shell output
warn() { echo "$@" >&2; }
die() { warn "Fatal: $@"; exit 1; }

escape() {
	echo "$1" | sed 's/\([\.\$\*]\)/\\\1/g'
}

# Set logic
has() {
	local item=$1; shift
	echo " $@ " | grep -q " $(escape $item) "
}

# Basic math
min() { [ "$1" -le "$2" ] && echo "$1" || echo "$2"; }
max() { [ "$1" -ge "$2" ] && echo "$1" || echo "$2"; }

# Basic string matching
startswith() { [ "$1" != "${1#$2}" ]; }
endswith() { [ "$1" != "${1%$2}" ]; }

# Convenience functions for checking shFlags flags
flag() { local FLAG; eval FLAG='$FLAGS_'$1; [ $FLAG -eq $FLAGS_TRUE ]; }
noflag() { local FLAG; eval FLAG='$FLAGS_'$1; [ $FLAG -ne $FLAGS_TRUE ]; }

#
# Git specific common functionality
#

git_local_branches() { git for-each-ref --format='%(refname:short)' refs/heads; }
git_remote_branches() { git for-each-ref --format='%(refname:short)' refs/remotes; }
git_all_branches() { git for-each-ref --format='%(refname:short)' refs/remotes refs/heads; }
git_all_tags() { git for-each-ref --format='%(refname:short)' refs/tags; }

git_local_branches_prefixed() {
	[ -z $1 ] && die "Prefix parameter missing." # This should never happen.
	git for-each-ref --format='%(refname:short)' refs/heads/$1 ;
}
git_current_branch() {
	local branch_name="$(git symbolic-ref --quiet HEAD)"
	[ -z $branch_name ] && branch_name="(unnamed branch)" || branch_name="$(git for-each-ref --format='%(refname:short)' $branch_name)"
	echo "$branch_name"
}

git_is_clean_working_tree() {
	git rev-parse --verify HEAD >/dev/null || exit 1
	git update-index -q --ignore-submodules --refresh

	# Check for unstaged changes
	git diff-files --quiet --ignore-submodules || return 1

	# Check for Uncommited changes
	git diff-index --cached --quiet --ignore-submodules HEAD -- || return 2

	return 0
}

git_repo_is_headless() {
	! git rev-parse --quiet --verify HEAD >/dev/null 2>&1
}

git_local_branch_exists() {
	[ -n "$1" ] || die "Missing branch name"
	[ -n "$(git for-each-ref --format='%(refname:short)' refs/heads/$1)" ]
}

git_remote_branch_exists() {
	[ -n "$1" ] || die "Missing branch name"
	[ -n "$(git for-each-ref --format='%(refname:short)' refs/remotes/$1)" ]
}

git_remote_branch_delete() {
	[ -n "$1" ] || die "Missing branch name"
	if git_remote_branch_exists "$ORIGIN/$1"; then
		git push "$ORIGIN" :"$1" || die "Could not delete the remote $1 in $ORIGIN."
	else
		warn "Trying to delete the remote branch $1, but it does not exists in $ORIGIN"
	fi
}

git_branch_exists() {
	[ -n "$1" ] || die "Missing branch name"
	git_local_branch_exists "$1" || git_remote_branch_exists "$ORIGIN/$1"
}

git_tag_exists() {
	[ -n "$1" ] || die "Missing tag name"
	[ -n "$(git for-each-ref --format='%(refname:short)' refs/tags/$1)" ]
}

#
# git_compare_branches()
#
# Tests whether branches and their "origin" counterparts have diverged and need
# merging first. It returns error codes to provide more detail, like so:
#
# 0    Branch heads point to the same commit
# 1    First given branch needs fast-forwarding
# 2    Second given branch needs fast-forwarding
# 3    Branch needs a real merge
# 4    There is no merge base, i.e. the branches have no common ancestors
#
git_compare_branches() {
	local commit1=$(git rev-parse "$1")
	local commit2=$(git rev-parse "$2")
	if [ "$commit1" != "$commit2" ]; then
		local base=$(git merge-base "$commit1" "$commit2")
		if [ $? -ne 0 ]; then
			return 4
		elif [ "$commit1" = "$base" ]; then
			return 1
		elif [ "$commit2" = "$base" ]; then
			return 2
		else
			return 3
		fi
	else
		return 0
	fi
}

#
# git_is_branch_merged_into()
#
# Checks whether branch $1 is successfully merged into $2
#
git_is_branch_merged_into() {
	local merge_hash=$(git merge-base "$1"^{} "$2"^{})
	local base_hash=$(git rev-parse "$1"^{})

	# If the hashes are equal, the branches are merged.
	[ "$merge_hash" = "$base_hash" ]
}

#
# git_is_ancestor()
#
# This is the same function as git_is_branch_merged_into but
# for readability given a different name.
#
git_is_ancestor() {
	git_is_branch_merged_into "$1" "$2"
}

#
# git_fetch_branch()
#
# $1 Origin - Where to fetch from
# $2 Branch - Which branch to fetch
#
# This fetches the given branch from the given origin.
# Instead of storing it in FETCH_HEAD it will be stored in
# refs/remotes/<origin>/<branch>
#
git_fetch_branch() {
	[ -n "$1" ] || die "Missing origin"
	[ -n "$2" ] || die "Missing branch name"
	local origin="$1"
	local branch="$2"
	git fetch -q "$origin" "$branch":refs/remotes/"$origin"/"$branch" || die "Could not fetch $branch from $origin."
}

#
# gitflow specific common functionality
#

gitflow_require_version_arg() {
	if [ "$VERSION" = "" ]; then
		warn "Missing argument <version>"
		usage
		exit 1
	fi
}

gitflow_require_name_arg() {
	if [ "$NAME" = "" ]; then
		warn "Missing argument <name>"
		usage
		exit 1
	fi
}

gitflow_require_base_arg() {
	if [ "$BASE" = "" ]; then
		warn "Missing argument <base>"
		usage
		exit 1
	fi
}

# Function used to check if the repository is git-flow enabled.
gitflow_has_master_configured() {
	local master=$(git config --get gitflow.branch.master)
	[ "$master" != "" ] && git_local_branch_exists "$master"
}

gitflow_has_develop_configured() {
	local develop=$(git config --get gitflow.branch.develop)
	[ "$develop" != "" ] && git_local_branch_exists "$develop"
}

gitflow_has_prefixes_configured() {
	git config --get gitflow.prefix.feature >/dev/null 2>&1     && \
	git config --get gitflow.prefix.release >/dev/null 2>&1     && \
	git config --get gitflow.prefix.hotfix >/dev/null 2>&1      && \
	git config --get gitflow.prefix.support >/dev/null 2>&1     && \
	git config --get gitflow.prefix.versiontag >/dev/null 2>&1
}

gitflow_is_initialized() {
	gitflow_has_master_configured                    && \
	gitflow_has_develop_configured                   && \
	[ "$(git config --get gitflow.branch.master)" != "$(git config --get gitflow.branch.develop)" ] && \
	gitflow_has_prefixes_configured
}

# Loading settings that can be overridden using git config
gitflow_load_settings() {
	export DOT_GIT_DIR=$(git rev-parse --git-dir 2>/dev/null)
	export HOOKS_DIR="$DOT_GIT_DIR"/hooks
	export MASTER_BRANCH=$(git config --get gitflow.branch.master)
	export DEVELOP_BRANCH=$(git config --get gitflow.branch.develop)
	export ORIGIN=$(git config --get gitflow.origin || echo origin)
}

#
# gitflow_resolve_nameprefix
#
# Inputs:
# $1 = name prefix to resolve
# $2 = branch prefix to use
#
# Searches branch names from git_local_branches() to look for a unique
# branch name whose name starts with the given name prefix.
#
# There are multiple exit codes possible:
# 0: The unambiguous full name of the branch is written to stdout
#    (success)
# 1: No match is found.
# 2: Multiple matches found. These matches are written to stderr
#
gitflow_resolve_nameprefix() {
	local name=$1
	local prefix=$2
	local matches
	local num_matches

	# first, check if there is a perfect match
	if git_local_branch_exists "$prefix$name"; then
		echo "$name"
		return 0
	fi

	matches=$(echo "$(git_local_branches)" | grep "^$(escape "$prefix$name")")
	num_matches=$(echo "$matches" | wc -l)
	if [ -z "$matches" ]; then
		# no prefix match, so take it literally
		warn "No branch matches prefix '$name'"
		return 1
	else
		if [ $num_matches -eq 1 ]; then
			echo "${matches#$prefix}"
			return 0
		else
			# multiple matches, cannot decide
			warn "Multiple branches match prefix '$name':"
			for match in $matches; do
				warn "- $match"
			done
			return 2
		fi
	fi
}

#
# Check if the given branch is a git-flow branch
#
gitflow_is_prefixed_branch() {
	local branch=$1
	case $branch in
	$(git config --get gitflow.prefix.feature)* | \
	$(git config --get gitflow.prefix.release)* | \
	$(git config --get gitflow.prefix.hotfix)*  | \
	$(git config --get gitflow.prefix.support)* )
		return=0
		;;
	*)
		return=1
		;;
	esac
	return $return
}

#
# Assertions for use in git-flow subcommands
#

require_git_repo() {
	git rev-parse 2>/dev/null || die "Not a git repository"
}

require_gitflow_initialized() {
	 gitflow_is_initialized || die "Not a gitflow-enabled repo yet. Please run 'git flow init' first."
}

require_clean_working_tree() {
	git_is_clean_working_tree
	local result=$?
	if [ $result -eq 1 ]; then
		die "Working tree contains unstaged changes. Aborting."
	fi
	if [ $result -eq 2 ]; then
		die "Index contains uncommited changes. Aborting."
	fi
}

require_local_branch() {
	git_local_branch_exists "$1" || die "Local branch '$1' does not exist and is required."
}

require_remote_branch() {
	git_remote_branch_exists "$1" || die "Remote branch '$1' does not exist and is required."
}

require_branch() {
	git_branch_exists "$1" || die "Branch '$1' does not exist and is required."
}

require_branch_absent() {
	git_branch_exists "$1" && die "Branch '$1' already exists. Pick another name."
}

require_tag_absent() {
	git_tag_exists "$1" && die "Tag '$1' already exists. Pick another name."
}

require_branches_equal() {
	require_local_branch "$1"
	require_remote_branch "$2"
	git_compare_branches "$1" "$2"
	local status=$?
	if [ $status -gt 0 ]; then
		warn "Branches '$1' and '$2' have diverged."
		if [ $status -eq 1 ]; then
			die "And branch '$1' may be fast-forwarded."
		elif [ $status -eq 2 ]; then
			# Warn here, since there is no harm in being ahead
			warn "And local branch '$1' is ahead of '$2'."
		else
			die "Branches need merging first."
		fi
	fi
}

#
# run_filter_hook
#
# Looks for a Git hook script called as defined by the first variable
#
#     filter-flow-command
#
# If such a hook script exists and is executable, it is called with the given
# positional arguments.
#
run_filter_hook() {
	local command=$1
	shift
	local scriptfile="${HOOKS_DIR}/filter-flow-${command}"
	if [ -x $scriptfile ]; then
		echo `$scriptfile "$@"`
	else
		echo "$@"
        fi
}

#
# run_pre_hook
#
# Looks for a Git hook script called
#
#     pre-flow-<subcmd>-<subaction>
#
# If such a hook script exists and is executable, it is called with the given
# positional arguments.  If its return code non-zero, the git-flow action is
# aborted.
#
run_pre_hook() {
	local scriptfile="${HOOKS_DIR}/pre-flow-${SUBCOMMAND}-${SUBACTION}"
	local exitcode=0

	if [ -x $scriptfile ]; then
		$scriptfile "$@"
		exitcode=$?

		if [ $exitcode -gt 0 ]; then
			die "Hook command $scriptfile ended with exit code $exitcode."
		fi
	fi
}

#
# run_post_hook
#
# Looks for a Git hook script called
#
#     post-flow-<subcmd>-<subaction>
#
# If such a hook script exists and is executable, it is called with the given
# positional arguments.  Its return code is ignored.
#
run_post_hook() {
	local scriptfile="${HOOKS_DIR}/post-flow-${SUBCOMMAND}-${SUBACTION}"
	if [ -x $scriptfile ]; then
		$scriptfile "$@"
	fi
}
